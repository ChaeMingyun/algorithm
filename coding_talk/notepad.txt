1.1 2의 거듭제곱으로 나눈 몫을 구하려면 >> 연산자를 사용하면 된다.
     9 >> 2 == 2,  153 >> 2 == 38
1.2 2의 거듭제곱을 곱하려면 << 연산자를 사용하면 된다.
     9 << 2 == 9 * 4

2.1 짝수인지 홀수인지 구하려면 n&1 을 사용하면 된다.
2.2 2의n승으로 나눈 나머지를 구하려면 n&(2의n승 - 1)을 하면 된다. 이때 2의 n승은 1<<n 이다. 따라서 n&((1<<n)-1)

3.1 오른쪽에서부터 k 번째 bitmasking 을 하려면 1<<k 를 하면 된다.
3.2 숫자 n 이 오른쪽에서 부터 k 번째 비트가 1인지 0인지를 구하려면 n&(1<<k) 혹은 (n>>k)&1 을 사용하면 된다.

4.1 XOR 의 성질을 알아보자.
     Q. XOR 은 해당 비트가 같으면 0 다르면 1이 되는 비트연산자인데 여러 번 XOR 연산자를 사용하면 어떤 결과가 도출될까?
     A. 해당 비트에 1이 홀수면 1 짝수면 0이 나오는 결과가 나온다. 1이 두 번 만나면 0이 되므로!

5. 10만 또는 50만 : O(n), O(nlogn),
    1만 : O(n^2),
    5천 : O(n^2),
    1천 : O(n^2), O(n^2logn),
    1백 : O(n^4)
    입력 n 의 크기에 따라 1초(1억번 계산) 안에 계산가능한 마지노선 시간복잡도.

6. 하나의 경우를 구하는데 O(n+m) 의 시간복잡도가 걸리는 문제에
   모든 경우를 구하는데 O(n+m) 의 시간복잡도가 걸리는 경우도 종종있다.(A3-4, A3-5 참고)

7.1 실행시간의 최적화를 위해서는 기대함수(h(x))를 사용하는 것이 좋다. (이때까지 처리된 결과를 g(x) 라 부름. g(x) + h(x) 를 최적화할 때 사용!)
    기대함수란 현 시점에서 처리완료시점까지의 기대비용을 계산하는 식인데, 함수를 정의하는 방식은 다양하다.
7.2 memoization 을 사용하면 시간복잡도 또한 memoization 을 사용하기 위한 배열의 공간복잡도와 동일하다.

8. String Matching Algorithm
8.1 KMP 알고리즘 - O(N+M) (+내용 : aho-corasick - O(N + ΣMi)n 개의 문자열 m(m1 + m2 + m3 + ... + mk) 문자열이 있을 때.)
    0. KMP 알고리즘은 입력 문자열도 1번째 인덱스부터 입력 받는게 코드가 짧아져서 좋다.
    1. Failure Function
        12121 의 경우, 사이즈 6의 배열에 -1 0 0 1 2 3 을 채워준다. (0번째 배열에는 무조건 -1 넣는 것 주의.)
        이때, 배열에 들어가는 숫자의 의미는 본인을 제외한 접두사 접미사의 최장길이.
    2. Matching
        n 사이즈 문자열 A, m 사이즈 문자열 B가 있을 때, 투 포인터 중에서 i는 앞으로만 가고, j는 무조건 failure table 을 타고 이동한다.
        비교는 A[i] 와 B[j+1]을 한다.
        A[i] == B[j+1] 일 때, i++, j++ 을 시켜준다.
        시간복잡도가 O(N+M)인 이유는, j가 뒤로가려고 해도 i랑 같이 증가한뒤 뒤로가야하므로, 아무리 뒤로 가봤자 n 번을 못가기 때문이다.
8.2 Rabin-Karp 알고리즘 - O(N+M)
    hashing 을 사용한 알고리즘이다.
    n 사이즈의 문자열 A 와 m 사이즈의 문자열 B가 있다고 가정하자.
    사이즈 m 만큼의 문자열을 hashing 여러 개의 hash table 에 넣어 놓는다. 여러 개 라는 것은 예시로 든 101말고도 여러가지 숫자를 사용.
    (ex: (101^m-1 + ... + 101^2 + 101 + 1) % 101)
    이렇게 hash table 여러개를 참조해도 값이 다 똑같다면 같은 문자열인 것으로 가정하는 알고리즘이다.
    시간복잡도가 O(n+m)을 보장하는 이유는, n 사이즈의 문자열 중 첫 m 사이즈 문자열만 hashing 을 한 뒤, 한 칸씩만 뒤로 옮기면서 기존에 사용한 hashing 결과를 사용하면 되기 때문이다.
8.3 Boyer-Moore 알고리즘 - Avg(n/m), O(n^2)
    검색 알고리즘은 휴리스틱 알고리즘 두 개가 섞인 Boyer-Moore 알고리즘으로 짠다.
9. full segment tree
9.1 누적합 Si = A1 + ... + Ai,  a~b의 합 = Sb - Sa + Aa,  O(n+g)
9.2 수정이 빈번한 배열의 누적합 펜윅트리 https://www.acmicpc.net/blog/view/21 참고
9.3 세그먼트 트리 글 https://www.acmicpc.net/blog/view/26 참고

